tosca_definitions_version: tosca_simple_yaml_1_3
description: A TOSCA template to implement migration of cloud based app server software from cloud to specific MEC DCs. First used as part of 5G Riders on the Storm 2020 Catalyst for TMForum for hosting WheresMyChargePoint

metadata:
  # The following fields are "normative" and expected in TOSCA 
  template_name: AssuredHosting
  template_author: paul.m.jordan@bt.com
  template_version: '2.0'
  parse_command: puccini-tosca parse "tosca/Assured hosting.yml" -i csar_repo_URL="url" -i csar_repo_account="acc" > /dev/null

# imports:
#   # - file: https://github.com/pmjordan/TOSCA_for_TMForum/blob/master/sid.yml
#   # would normally refer to external repository but for now make it local
#   - file: ../../../../TOSCA_for_TMForum/sid.yml
#   # The content is a TOSCA encoding of selected SID information model entities as explained in IG1176
#     namespace_prefix: sid

#repositories:
# TOSCA repositories are not used as the URL cannot be parameterized.

node_types:
  myapp_type:
    derived_from: tosca.nodes.SoftwareComponent
    # artifacts are not used as the location cannot be parameterized.
    interfaces:
      Standard:
        operations:
          create:
            implementation: scripts/create.sh # content of create.sh would be written to get csar from repo and then use that csar to install as normal.
            inputs:
              csar_repo_URL:
                type: string
              csar_repo_account:
                type: string
              # csar_repo_pass:
              #   type: string
              # csar_file:
              #   type: string

  

topology_template:
  inputs:
    csar_repo_URL:
      type: string
    csar_repo_account:
      type: string
    csar_repo_pass:
      type: string
    csar_file:
      type: string

  node_templates:
    myApp:
      # as this is a classic VNF we have a choice of how to model it. Could be based on TOSCA node types, SID software entities or ETSI VNFs. Depends on what is easiest for the orchestrator vendor. 
      # Initially we tried to use TOSCA native but in this scenario the create artefact URL and the URL of the repository on which it is store both need to be passed in as inputs but TOSCA does not allow these to be paramterized.
      # We have therefore chosen SID to model the repository
      type: myapp_type #tosca.nodes.SoftwareComponent
      interfaces:
        Standard:
          operations:
            create:
              implementation: scripts/create.sh # content of create.sh would be written to get csar from repo and then use that csar to install as normal.
              inputs:
                csar_repo_URL: { get_input: csar_repo_URL }
                csar_repo_account: { get_input: csar_repo_account }
      #           csar_repo_pass: { get_input: csar_repo_pass }
      #           csar_file: { get_input: csar_file }
      requirements:
        # SoftwareComponent requires hosting on Compute by definition but supplement that requirement for an abstract node
        - host: myapp_compute

    # Abstract node template (placeholder) to be selected by provider        
    myapp_compute:
      type : tosca.nodes.Compute
      # directives: [ select ]
      # This node_filter is required by commented out awaiting a fix for puccini issue #34
      # node_filter:
      #   capabilities:
      #     - host:
      #         attributes:
      #           - private_address: { equal: {get_input: [ targetComputeAdminAddress ] }}